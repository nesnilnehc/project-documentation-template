# 语义化版本管理规范

## 概述

本文档基于语义化版本控制 2.0.0 规范，定义了完整的版本号管理标准。通过精确规范版本号与开发阶段、迭代周期、构建过程、分支策略、提交哈希等核心要素的映射关系，构建统一的版本管理体系，确保软件开发生命周期中版本信息的一致性、可追溯性和实用性。

### 设计原则

1. **语义明确性**：版本号能够清晰表达软件变更的性质和规模
2. **一致性保证**：跨阶段、分支、构建、环境的版本标识保持一致
3. **可追溯性**：任何版本都能追溯到具体的代码状态和构建信息
4. **兼容性优先**：在遵循 SemVer 2.0.0 规范的基础上，优先考虑实际应用的兼容性（如 Docker、包管理器等）

## 版本号格式规范

### 基本格式

基于语义化版本控制 2.0.0 规范，采用兼容性更好的格式：

```text
<major>.<minor>.<patch>[-<prerelease>][-<buildmetadata>]
```

**中文对照**：

```text
主版本号.次版本号.修订版本号[-预发布标识符][-构建元数据]
```

### 重要说明

本规范为了确保跨平台兼容性，**主动放弃了语义化版本规范中的 `+` 号**，统一使用 `-` 号分隔构建元数据。

#### 原因

- Docker 标签规范不允许使用 `+` 号
- 大多数包管理器（npm、pip、maven 等）对 `+` 号支持有限
- Kubernetes 资源名称不支持 `+` 号
- 文件系统在某些情况下对 `+` 号处理不当

#### 语义影响

- 在 SemVer 规范中，`+` 号用于构建元数据，`-` 号用于预发布版本
- 本规范将构建元数据改为使用 `-` 号，**改变了版本号的语义**
- 例如：`1.6.0-alpha.1-20250930.001.develop.a1b2c3d` 在 SemVer 中会被解析为预发布版本，而非正式版本+构建元数据

#### 权衡

虽然改变了 SemVer 的语义，但确保了版本号在各种实际应用场景中的可用性和一致性。

### 组成部分说明

1. **主版本号（Major）**：包含破坏性变更时递增
2. **次版本号（Minor）**：添加新功能但保持向后兼容时递增
3. **修订版本号（Patch）**：进行向后兼容的 bug 修复时递增
4. **预发布标识符**：表示版本的成熟度和稳定性，影响版本优先级排序
5. **构建元数据**：包含构建相关信息，不影响版本优先级，仅用于标识和追溯

## 版本号递增计算规则

### 基本递增规则

| 版本类型 | 递增条件 | 重置规则 | 示例 |
|----------|----------|----------|------|
| **主版本号** | 破坏性变更（API 不兼容、数据结构变更） | 次版本号和修订版本号重置为 0 | `1.5.3` → `2.0.0` |
| **次版本号** | 向后兼容的新功能 | 修订版本号重置为 0 | `1.5.3` → `1.6.0` |
| **修订版本号** | 向后兼容的 bug 修复 | 无重置 | `1.5.3` → `1.5.4` |

### 预发布版本规则

- **阶段内递增**：`1.6.0-alpha.1` → `1.6.0-alpha.2`
- **阶段间递增**：`1.6.0-alpha.2` → `1.6.0-beta.1`
- **正式发布**：`1.6.0-rc.3` → `1.6.0`
- **阶段优先级**：`alpha` < `beta` < `rc` < 正式版本

### 预发布标识符结构

**预发布标识符部分（`-<prerelease>`）**：

- **stage**：开发阶段标识（alpha、beta、rc）
- **iteration**：同一阶段内的迭代序号（可选，纯数字，如 1、2、3）
- **格式**：`<stage>[.<iteration>]`

**构建元数据部分（`-<buildmetadata>`）**：

- **构建时间戳**：构建时间标识（必需，格式：YYYYMMDD）
- **构建序号**：可选的构建编号（三位数字，如 001、010、015）
- **构建分支**：非主分支时包含分支信息（主分支如 main、master 时隐藏）
- **Git 哈希**：提交哈希值（必需，7 位短哈希）
- **格式**：`<timestamp>[.<buildnumber>][.<branch>].<githash>`

**分支处理规则**：

- **主分支**（main、master）：分支信息隐藏，格式为 `<timestamp>[.<buildnumber>].<githash>`
- **非主分支**（develop、feature、hotfix 等）：包含分支信息，格式为 `<timestamp>[.<buildnumber>].<branch>.<githash>`

### 重要约束

- **环境信息**（dev、test、staging、prod）不属于版本号，应通过部署配置管理
- **分支信息**（feature、hotfix、bugfix 等）不属于版本号，应放在构建元数据中
- **iteration 仅为数字**：不包含 dev、hotfix、feat 等分支类型信息
- 同一版本可以部署到不同环境，环境不应影响版本标识

## 版本示例

### 常见版本示例

| 版本类型 | 版本号示例 | 说明 |
|----------|------------|------|
| **开发版本** | `1.6.0-alpha.1-20250930.001.develop.a1b2c3d` | 开发分支的 alpha 版本，包含分支信息 |
| **测试版本** | `1.6.0-beta.1-20250930.010.develop.b2c3d4e` | 开发分支的 beta 版本，构建序号递增 |
| **候选版本** | `1.6.0-rc.1-20250930.015.release.c3d4e5f` | 发布分支的候选版本，包含分支信息 |
| **正式版本** | `1.6.0-20250930.020.d4e5f6g` | 主分支的正式版本，分支信息隐藏 |
| **功能分支** | `1.6.0-alpha.1-20250930.005.feature.e5f6g7h` | 功能分支的开发版本，包含分支信息 |
| **修复分支** | `1.6.1-rc.1-20250930.001.hotfix.f6g7h8i` | 热修复分支的候选版本，包含分支信息 |

**分支信息处理**：

- **主分支**（main、master）：版本号中不包含分支信息，如 `1.6.0-20250930.020.d4e5f6g`
- **非主分支**：版本号中包含分支信息，如 `1.6.0-alpha.1-20250930.001.develop.a1b2c3d`

## 版本生命周期工作流

### 完整生命周期图

```mermaid
graph TD
    A[开始开发] --> B["1.6.0-alpha.1<br/>-20250930.001.develop.a1b2c3d"]
    B --> C{功能开发完成?}
    C -->|否| B
    C -->|是| D["1.6.0-beta.1<br/>-20250930.010.develop.b2c3d4e"]
    
    D --> E{测试通过?}
    E -->|否| F[修复问题]
    F --> D
    E -->|是| G["1.6.0-rc.1<br/>-20250930.015.release.c3d4e5f"]
    
    G --> H{预发布验证通过?}
    H -->|否| I[修复问题]
    I --> G
    H -->|是| J["1.6.0<br/>-20250930.020.d4e5f6g"]
    
    J --> K[发布完成]
    K --> L["1.7.0-alpha.1<br/>-20251001.001.develop.e5f6g7h"]
    L --> M[下一版本开发]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style K fill:#c8e6c9
    style B fill:#fff3e0
    style D fill:#fff3e0
    style G fill:#fff3e0
```

**分支信息说明**：

- **develop 分支**：包含分支信息 `develop`
- **release 分支**：包含分支信息 `release`  
- **main 分支**：分支信息隐藏（正式版本）

### 关键节点控制

| 节点 | 控制条件 | 负责角色 | 输出产物 |
|------|----------|----------|----------|
| **开发完成** | 功能实现完整，单元测试通过 | 开发团队 | alpha 版本 |
| **测试通过** | 集成测试、系统测试通过 | 测试团队 | beta 版本 |
| **预发布验证** | 性能测试、安全测试通过 | 运维团队 | rc 版本 |
| **正式发布** | 业务验收、发布审批通过 | 产品团队 | 正式版本 |

## 版本验收与发布流程

### 核心原则

遵循"你测试的即你发布的"（What You Test Is What You Ship），确保测试环境与生产环境使用完全相同的二进制制品。

### 实施方法

将已通过验收的构建制品从临时存储仓库（如 `snapshots`、`testing`）直接迁移至正式发布仓库（如 `releases`、`production`），避免重新构建导致的潜在差异。

### 业界标准实践

| 标记方式 | 工具/平台 | 核心操作与目的 |
|----------|-----------|----------------|
| **制品库晋级** | Artifactory, Nexus, Harbor | 将已验证的制品从测试仓库迁移至不可变的发布仓库，确保发布制品与测试制品的二进制一致性 |
| **CI/CD 流水线** | Jenkins, GitLab CI, GitHub Actions | 设置手动审批节点，验收通过后自动执行发布操作（标签创建、制品晋级等） |

## 规范说明

### 与 SemVer 2.0.0 的差异

- **分隔符差异**：本规范使用 `-` 号分隔构建元数据，而非 SemVer 标准的 `+` 号
- **语义差异**：在 SemVer 中，`-` 号用于预发布版本，`+` 号用于构建元数据；本规范统一使用 `-` 号，改变了版本号的语义解析
- **兼容性考虑**：这是为了确保与 Docker、Kubernetes、包管理器等实际应用场景的兼容性
- **影响范围**：使用本规范的版本号在标准的 SemVer 解析器中可能被误解析为预发布版本
- **权衡结果**：虽然改变了 SemVer 的语义，但确保了版本号在各种实际应用场景中的可用性和一致性

## 参考资料

- [语义化版本规范 2.0.0](https://semver.org/lang/zh-CN/) - 本规范基于此标准，但为兼容性考虑使用 `-` 号替代 `+` 号
- [Git 分支管理最佳实践](https://nvie.com/posts/a-successful-git-branching-model/)
- [持续集成与持续部署指南](https://martinfowler.com/articles/continuousIntegration.html)
- [软件配置管理最佳实践](https://www.ibm.com/docs/en/engineering-lifecycle-management-suite/lifecycle-management/6.0.6)
- [版本控制系统设计原则](https://git-scm.com/book/zh/v2)
